# Nginx File Name Logic Vulnerability (CVE-2013-4547)

## Vulnerability Description

Impact version: Nginx 0.8.41 ~ 1.4.3 / 1.5.0 ~ 1.5.7

Reference link:

 - http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-4547
 - https://blog.werner.wiki/file-resolution-vulnerability-nginx/
 - http://www.91ri.org/9064.html

## Vulnerability Description

This vulnerability is not much related to code execution. The main reason is that the requested URI is incorrectly parsed, and the file name requested by the user is incorrectly obtained, resulting in the effect of permission bypass and code execution.

For example, if Nginx matches a request ending in .php, it will be sent to fastcgi for parsing. The common way of writing is as follows:

```
Location ~ \.php$ {
    Include fastcgi_params;

    Fastcgi_pass 127.0.0.1:9000;
    Fastcgi_index index.php;
    Fastcgi_param SCRIPT_FILENAME /var/www/html$fastcgi_script_name;
    Fastcgi_param DOCUMENT_ROOT /var/www/html;
}
```

Under normal circumstances (in the case of closing pathinfo), only files with a .php suffix will be sent to fastcgi for parsing.

In the case of CVE-2013-4547, we request `1.gif[0x20][0x00].php`, this URI can match the upper regular `\.php$`, you can enter this Location block; but after entering, Nginx mistakenly believes that the requested file is `1.gif[0x20]`, and sets the value of `SCRIPT_FILENAME` to fastcgi.

Fastcgi parses according to the value of `SCRIPT_FILENAME`, which eventually causes a parsing vulnerability.

So, we only need to upload a file with a space ending, so that PHP can parse it.

As another example, for example, many websites limit the IP that allows access to the background:

```
Location /admin/ {
    Allow 127.0.0.1;
    Deny all;
}
```

We can request the following URI: `/test[0x20]/../admin/index.php`, this URI will not match the `/admin/` after the location, and it will bypass the IP verification; but finally The request is `/test[0x20]/../admin/index.php` file, which is `/admin/index.php`, and successfully accesses the background. (The premise is that there needs to be a directory called `test `: This is a feature of the Linux system. If there is a directory that does not exist, even if it jumps to the previous level, it will explode the file does not exist. Windows does not have this. limit)

## Vulnerability Testing

Start the vulnerability environment:

```
Docker-compose build
Docker-compose up -d
```

After the environment is started, you can see an upload page by visiting `http://your-ip:8080/`.

This environment is blacklisted. We can't upload files with php suffixes. We need to use CVE-2013-4547. We upload a `1.gif ` and notice the following spaces:

![](01.png)

Go to `http://your-ip:8080/uploadfiles/1.gif[0x20][0x00].php` and you'll see that PHP has been parsed:

![](02.png)

Note that [0x20] is a space and [0x00] is `\0`, neither of which requires encoding.